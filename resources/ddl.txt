create table all_beat (bar_id integer, beat_id integer);

create table song (
  song_id            integer not null,
  song_nm            varchar(50),
  time_sig_nmrtr_num integer,
  time_sig_denom_num integer,
  time_sig_ppq_num   integer,
  time_sig_bb_num    integer,
  bpm_num            integer,
  primary key(song_id)
);

create table bar (
  song_id integer not null,
  bar_id  integer not null,
  beat_id integer not null,
  chord_id varchar(20),
  primary key (song_id, bar_id, beat_id)
);

select a.bar_id, a.beat_id, b.chord_id
from all_beat      a
     left join bar b on (b.bar_id  = a.bar_id and
                         b.beat_id = a.beat_id)
where a.beat_id <= 4 and
      a.bar_id <= (select max(bar_id) max_bar from bar where song_id = 1) and
      b.song_id = 1
order by a.bar_id, a.beat_id;


select * from bar_flat;

drop view bar_flat;

create view bar_flat
as
select b.song_id, b.bar_id, b.beat_id, b.chord_id,
       s.song_nm, s.time_sig_nmrtr_num, s.time_sig_denom_num,
       s.time_sig_ppq_num, s.time_sig_bb_num  
from bar             b
     inner join song s on (s.song_id = b.song_id);
                 

with
song as (select * from bar_flat where song_id = 2),
fill as (
    select a.bar_id, a.beat_id, b.bar_id orig_bar_id, b.beat_id orig_beat_id,
           b.chord_id,
           lag(b.chord_id, 1) over (partition by a.bar_id order by a.beat_id) c1,
           lag(b.chord_id, 2) over (partition by a.bar_id order by a.beat_id) c2,
           lag(b.chord_id, 3) over (partition by a.bar_id order by a.beat_id) c3,
           lag(b.chord_id, 4) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c4,
           lag(b.chord_id, 5) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c5,
           lag(b.chord_id, 6) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c6,
           lag(b.chord_id, 7) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c7,
           lag(b.chord_id, 8) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c8
    from all_beat                 a
         left outer join bar_flat b on (a.bar_id = b.bar_id and a.beat_id = b.beat_id)
    where song_id = 2 
     ),
rc as (select bar_id, beat_id, coalesce(chord_id, c1, c2, c3, c4, c5, c6, c7, c8) chord_id,
              orig_bar_id, orig_beat_id, chord_id orig_chord_id
       from fill)
select * from rc
-- where chord_id is not null
order by 1, 2;

with
bars as (select * from bar_flat where song_id = 6),
fill as (
    select a.bar_id, a.beat_id, b.bar_id orig_bar_id, b.beat_id orig_beat_id,
           b.chord_id,
           lag(b.chord_id, 1) over (partition by a.bar_id order by a.beat_id) c1,
           lag(b.chord_id, 2) over (partition by a.bar_id order by a.beat_id) c2,
           lag(b.chord_id, 3) over (partition by a.bar_id order by a.beat_id) c3,
           lag(b.chord_id, 4) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c4,
           lag(b.chord_id, 5) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c5,
           lag(b.chord_id, 6) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c6,
           lag(b.chord_id, 7) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c7,
           lag(b.chord_id, 8) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c8
    from all_beat             a
         left outer join bars b on (a.bar_id = b.bar_id and a.beat_id = b.beat_id)),
rc as (select bar_id, beat_id, coalesce(chord_id, c1, c2, c3, c4, c5, c6, c7, c8) chord_id
       from fill)
select * from rc
where chord_id is not null
order by 1, 2;

create table song_backup as select * from song;

create table bar_backup as select * from bar;

delete from song;
delete from bar;


--select * from all_beat order by 1, 2;
--select * from bar_flat order by 1, 2;
--select bar_id, beat_id, '[' ||chord_id || ']', length(chord_id), case when chord_id is null then 'Y' else 'N' end from bar order by 1, 2;
--select * from all_beat where beat_id <= 4;
--delete from all_beat;
--update bar set chord_id = null where length(chord_id) = 0;
    

select upper("Hello");

select * from bar where song_id = 5;

with
bars as (select * from bar_flat where upper(song_nm) = 'ALL THE THINGS YOU ARE'),
beats as (select * from all_beat where bar_id <= (select max(bar_id) from bars)),
fill as (
   select a.bar_id, a.beat_id, b.bar_id orig_bar_id, b.beat_id orig_beat_id,
          b.chord_id,
          lag(b.chord_id, 1) over (partition by a.bar_id order by a.beat_id) c1,
          lag(b.chord_id, 2) over (partition by a.bar_id order by a.beat_id) c2,
          lag(b.chord_id, 3) over (partition by a.bar_id order by a.beat_id) c3,
          lag(b.chord_id, 4) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c4,
          lag(b.chord_id, 5) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c5,
          lag(b.chord_id, 6) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c6,
          lag(b.chord_id, 7) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c7,
          lag(b.chord_id, 8) over (order by a.bar_id, a.beat_id range between unbounded preceding and current row) c8
   from beats                a
        left outer join bars b on (a.bar_id = b.bar_id and a.beat_id = b.beat_id)),
rc as (select bar_id, beat_id, coalesce(chord_id, c1, c2, c3, c4, c5, c6, c7, c8) chord_id
      from fill)
select bar_id, beat_id, chord_id
from rc
where chord_id is not null
order by bar_id, beat_id;
               
select * from bar where song_id = 1;

drop table chord;

create table chord (
   chord_id      varchar(20) not null primary key,
   root_midi_num integer,
   chord_form_cd varchar(10),
   root_note_cd  varchar(10),
   major_ind     char(1),
   midi1_num     integer,
   midi2_num     integer,
   midi3_num     integer,
   midi4_num     integer,
   midi5_num     integer,
   midi6_num     integer
);

drop table note;

create table note (
  note_cd varchar(10) not null primary key,
  midi_num integer
);

--         65  70   63   
-- (- 63)   2   7    0
-- (- 65)   0   5   -2


select bar_id, beat_id, chord_id, major_ind, midi1_num root, c.major_ind, midi1_num - 65
from bar              b
     left join chord c on (c.chord_id = b.chord_id)
where b.song_id = 1;

select * from note order by midi_num;

select * from chord;

select bar_id, beat_id, chord_id, major_ind, midi1_num root, c.major_ind,
       midi1_num -        lag(midi1_num) over (order by bar_id, beat_id),
       midi1_num - ( 12 + lag(midi1_num) over (order by bar_id, beat_id)),
       midi1_num - (-12 + lag(midi1_num) over (order by bar_id, beat_id))
from bar              b
     left join chord c on (c.chord_id = b.chord_id)
where b.song_id = 1;

with
t as (select bar_id, beat_id, b.chord_id, c.major_ind, midi1_num root, 
             lead(midi1_num) over (order by bar_id, beat_id) next_chord
      from bar              b
           left join chord c on (c.chord_id = b.chord_id)
      where b.song_id = 1)
select t.*,
       abs(root - next_chord)          d1,
       abs(root - (next_chord + 12))   d2,
       abs(root - (next_chord - 12))   d3,
       min(abs(root - next_chord),
           abs(root - (next_chord + 12)),
           abs(root - (next_chord - 12))) mindist,
       case when major_ind = 'N' then 'min' else 'maj' end ||
       min(abs(root - next_chord),
           abs(root - (next_chord + 12)),
           abs(root - (next_chord - 12))) int
from t;

--create table bass_ptrn (
--   bass_ptrn_id  varchar(30),
--   bar_id        integer,
--   beat_id       integer,
--   chord_id      varchar(10)
--);

select b.bar_id, b.beat_id, b.chord_id, c.root_midi_num, c.major_ind, p.*
from bar                  b
     left join chord      c on (b.chord_id = c.chord_id)
     left join chord_ptrn p on (p.chord_id = b.chord_id and
                                p.beat_id  = b.beat_id)
where b.song_id = 1 and
      p.bar_id  = 1;
      

with
s1 as (select b.song_id, p.bass_line_id, b.bar_id from_bar_id, b.bar_id + 1 next_bar_id, c.root_midi_num - 60 transp_num
       from bar             b
            join chord_ptrn_v p on (p.chord_id = b.chord_id and p.beat_id = b.beat_id)
       where p.bar_id  = 1),
s2 as (select s.song_id, s.bass_line_id, s.from_bar_id, s.transp_num, b.bar_id + 1 next_bar_id, b.chord_id
       from s1              s
            join bar        b  on (b.song_id  = s.song_id  and b.bar_id = s.next_bar_id)
            join chord_ptrn_v p  on (p.chord_id = b.chord_id and p.beat_id = b.beat_id and p.bass_line_id = s.bass_line_id)
       where p.bar_id = 2),
s3 as (select s.song_id, s.bass_line_id, s.from_bar_id, s.transp_num, b.bar_id + 1 next_bar_id, b.chord_id
       from s2              s
            join bar        b  on (b.song_id  = s.song_id  and b.bar_id = s.next_bar_id)
            join chord_ptrn_v p  on (p.chord_id = b.chord_id and p.beat_id = b.beat_id and p.bass_line_id = s.bass_line_id)
       where p.bar_id = 3),
s4 as (select s.song_id, s.bass_line_id, s.from_bar_id, s.transp_num, b.bar_id + 1 next_bar_id, b.chord_id
       from s3              s
            join bar        b  on (b.song_id  = s.song_id  and b.bar_id = s.next_bar_id)
            join chord_ptrn_v p  on (p.chord_id = b.chord_id and p.beat_id = b.beat_id and p.bass_line_id = s.bass_line_id)
       where p.bar_id = 4),
s5 as (select s.song_id, s.bass_line_id, s.from_bar_id, s.transp_num, b.bar_id + 1 next_bar_id, b.chord_id
       from s4              s
            join bar        b  on (b.song_id  = s.song_id  and b.bar_id = s.next_bar_id)
            join chord_ptrn_v p  on (p.chord_id = b.chord_id and p.beat_id = b.beat_id and p.bass_line_id = s.bass_line_id)
       where p.bar_id = 5)
select * from s4;


with recursive
s(song_id, bass_line_id, from_bar_id, next_bar_id, chord_id, step_num, bar_cnt) as (
         select b.song_id,
                p.bass_line_id,
                b.bar_id from_bar_id,
                b.bar_id + 1 next_bar_id,
--                c.root_midi_num - 60 transp_num,
                b.chord_id,
                p.bar_id step_num,
                p.bar_cnt
         from bar             b
              join chord_ptrn_v p on (p.chord_id = b.chord_id and
                                      p.beat_id  = b.beat_id)
         where p.bar_id  = 1
         union all
         select s.song_id,
                s.bass_line_id,
                s.from_bar_id,
                b.bar_id + 1 next_bar_id,
--                s.transp_num,
                b.chord_id,
                p.bar_id,
                s.bar_cnt
         from s
              join bar          b  on (b.song_id  = s.song_id  and
                                       b.bar_id   = s.next_bar_id)
              join chord_ptrn_v p  on (p.chord_id     = b.chord_id   and
                                       p.beat_id      = b.beat_id    and
                                       p.bass_line_id = s.bass_line_id)
       where p.bar_id = s.step_num + 1)
select * from s
where step_num = bar_cnt;



select * from bar where song_id = 1 order by bar_id, beat_id;

alter table chord add root_num integer;

select * from note;

drop table bass_ptrn;

create table chord_ptrn_hdr (
  bass_line_id varchar2(20) not null,
  bar_cnt      integer,
  primary key (bass_line_id)
);

delete from chord_ptrn_hdr;

insert into chord_ptrn_hdr (bass_line_id, bar_cnt)
values
  ('Line-A',  4),
  ('Line-A1', 4),
  ('251',     3);

create table chord_ptrn (
  bass_line_id varchar(20) not null,
  bar_id       integer     not null,
  beat_id      integer     not null,
  chord_id     varchar(20),
  primary key (bass_line_id, beat_id, bar_id)
);

select * from chord_ptrn;

delete from chord_ptrn;

insert into chord_ptrn (bass_line_id, bar_id, beat_id, chord_id)
values
  ('Line-A',  1, 1, 'Cm7'), ('Line-A',  2, 1, 'Fm7'), ('Line-A',  3, 1, 'Bb7'),    ('Line-A',  4, 1, 'Ebmaj7'),
  ('Line-A1', 1, 1, 'Cm7'), ('Line-A1', 2, 1, 'Fm7'), ('Line-A1', 3, 1, 'Bbmaj7'), ('Line-A1', 4, 1, 'Ebmaj7'),
  ('251',     1, 1, 'Am7'), ('251',     2, 1, 'D7'),  ('251',     3, 1, 'Gmaj7');
  
drop view chord_ptrn_v;

create view chord_ptrn_v as
with 
t as (select p.*, c.root_midi_num, c.chord_form_cd, n.midi_num, h.bar_cnt
      from chord_ptrn          p
           join chord_ptrn_hdr h on (h.bass_line_id = p.bass_line_id)
           join chord          c on (c.chord_id     = p.chord_id)
           cross join note     n
      where n.note_cd in ('c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'))
select t.bass_line_id, t.bar_id, t.beat_id, c.chord_id, t.bar_cnt,
  case when c.root_midi_num >= t.root_midi_num then
      (c.root_midi_num - t.root_midi_num)
  else
      (c.root_midi_num - t.root_midi_num) + 12
  end transp_num,
  t.root_midi_num ptrn_root_midi_num,
  c.root_midi_num transp_root_midi_num
from t
   left join chord c on (c.root_midi_num = t.midi_num and
                         c.chord_form_cd = t.chord_form_cd);
                         

select * from chord_ptrn_v
order by bass_line_id, transp_num, bar_id, beat_id;

